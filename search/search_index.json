{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Javascript Game with kaboom. /* Add some basic styling for the code box */ pre { background-color: #f4f4f4; padding: 10px; border-radius: 5px; } /* Optional: Style the code for better readability */ code { color: #333; font-family: 'Courier New', monospace; font-size: 15px; } .copy-button { position: absolute; top: 5px; right: 5px; cursor: pointer; } Today we will be learning how to make a dino-ish game in javascript lets start 1. Make a index.html file. the index.html file needs 2 elements called a head and a body 2. Make a new kaboom.js game by running npm i kaboom in your project this will make a easy way for you to use servers why? kaboom.js adds the npm run dev function 3. paste this in your html file // import kaboom lib import kaboom from \"https://unpkg.com/kaboom@3000.0.1/dist/kaboom.mjs\"; // initialize kaboom context kaboom(); // add a piece of text at position (120, 80) add([ text(\"hello\"), pos(120, 80), ]); This will make a piece of text on the screen. This is like legos kinda Okay lets start replace the code with /// start the game kaboom() // define gravity setGravity(2400) // load a default sprite loadBean() // add character to screen, from a list of components const player = add([ sprite(\"bean\"), // renders as a sprite pos(120, 80), // position in world area(), // has a collider body(), // responds to physics and gravity ]) \ud83d\udccb Copy and start. After that lets make it jump add this code to your script < onKeyPress(\"space\", () => { // .jump() is provided by the body() component player.jump() }) \ud83d\udccb Copy now before we run lets add a platorm for the player to stand on add this code add([ rect(width(), 48), pos(0, height() - 48), outline(4), area(), body({ isStatic: true }), color(127, 200, 255), ]) \ud83d\udccb Copy Woah! That looks like a lot, but it's actually really simple, let's look at each component rect() renders a rectangle. It accepts 2 arguments, the width and height, which we give it the game width (returned by width()) and height of 48 pixels pos() position. We give it a x: 0 and y: height() - 48 so it sits right on the bottom of the screen outline() renders an outline of 4 pixels area() adds a collider to it body({ isStatic: true }) the object won't move, and all non static objects won't move past it color() makes it render with an RGB color, we give it a R: 127 G: 200 B: 255 which is a blue-ish color Pretty straightforward! Refresh the game and you should see our Bean is now safely landed on a static blue platform. Let's also make sure our Bean can only jump when isGrounded. onKeyPress(\"space\", () => { if (bean.isGrounded()) { bean.jump(); } }); \ud83d\udccb Copy isGrounded() is another function provided by body() component which checks if currently landed on a platform. Now our game is slightly more physically correct. Bean loves challanges. Let's start adding in obstacles to jump over! Time to build a game object from components again. // add tree add([ rect(48, 64), area(), outline(4), pos(width(), height() - 48), anchor(\"botleft\"), color(255, 180, 255), move(LEFT, 240), ]); \ud83d\udccb Copy Challenger appears! Try jumping over it. Oh but it's.. not really fun! Or rather, there's no feedback to whether we managed to jump over the ramp. Let's add some feedback. To do this we'll need to check for collision between the two. First we'll need to give the tree a tag. Any game object can have any number of tags, they're kinda like components but much more light weight. We often use tags to quickly describe behaviors for a group of objects. // add tree add([ rect(48, 64), area(), outline(4), pos(width(), height() - 48), anchor(\"botleft\"), color(255, 180, 255), move(LEFT, 240), \"tree\", // add a tag here ]); \ud83d\udccb Copy To add a tag we simply put a string in the component array. Then we can check for collision between Bean and any object with tag \"tree\". bean.onCollide(\"tree\", () => { addKaboom(bean.pos); shake(); }); \ud83d\udccb Copy .onCollide() is a function provided by the area() component. It registers an event that runs every time the object collides with another object with a certain tag, passed by the first argument. In this case, it means every time Bean collides with another game obj with tag \"tree\", run the callback. Inside the callback we're doing 2 things. addKaboom() spawns an explosion animation which is basically kaboom's logo, it accepts 1 argument the position to spawn, which we pass in the player's current position with .pos (which is provided by the pos() component). The second thing is shake(), which just shakes the screen, Here's a trick. Try pressing F1 in the game. See all the blue outlines? This is inspect mode and it'll show all the bounding boxes of every game obj with area() component. Also try hovering over each game object to inspect its states like position and tags. Now it's time to add more trees. How can we keep them spawning constantly? Let's try the loop() function, which performs an action every x seconds. loop(1, () => { // add tree add([ rect(48, 64), area(), outline(4), pos(width(), height() - 48), anchor(\"botleft\"), color(255, 180, 255), move(LEFT, 240), \"tree\", // add a tag here ]); }); \ud83d\udccb Copy Let's just put the tree adding code inside a loop(). The first argument is the time in seconds here, so it'll spawn a tree every 1 seconds. Sick! Lots of trees coming to you now. Now we already have most of the game mechanics done. Some improvements we can make: It might be better if trees all have different random heights. We can use rand() to assign different value to the tree's rect height: function spawnTree() { add([ // the tree components ]); wait(rand(0.5, 1.5), () => { spawnTree(); }); } spawnTree(); \ud83d\udccb Copy See? We're calling spawnTree() recursively / endlessly, with a random interval between 0.5 - 1.5 seconds each time. Before adding a score counter, let's actually complete the game loop first, by sending player to a gameover scene when they hit a tree. We can achieve this with kaboom's scene() system scene(\"game\", () => { add([ sprite(\"bean\"), ]) }) scene(\"lose\", () => { add([ text(\"Game Over\"), ]) }) go(\"game\") \ud83d\udccb Copy Consider this example above, we're declaring 2 scenes here, \"game\" and \"lose\". The function we pass to scene() is the function to run when this scene is activated (by go()). In this case, we want to add a \"bean\" sprite on \"game\" scene, and want to add a \"Game Over\" text on the \"lose\" scene. Let's first move everything game code we have into a scene. // don't move these init / loader functions kaboom() loadSprite(\"bean\", \"sprites/bean.png\"); scene(\"game\", () => { // add bean // add platform // spawn trees }); go(\"game\") \ud83d\udccb Copy Try this, this shouldn't change any of your game's content. Then we can add a \"lose\" scene independent to your core game content here scene(\"lose\", () => { add([ text(\"Game Over\"), pos(center()), anchor(\"center\"), ]) }) \ud83d\udccb Copy So in the \"lose\" scene, we'll add a piece of text in the center says \"Game Over\" (text() is a component that renders text). Go ahead and go to this scene when player collides with a tree: player.onCollide(\"tree\", () => { addKaboom(bean.pos); shake(); go(\"lose\"); // go to \"lose\" scene here }); \ud83d\udccb Copy Ok! Now we've arrived at the final part of our game: score counter. let score = 0; const scoreLabel = add([ text(score), pos(24, 24) ]) \ud83d\udccb Copy Here we've declared a number variable to store the score, and added a game obj with text() component to display the text. Let's keep it simple and just use time as score. // increment score every frame onUpdate(() => { score++; scoreLabel.text = score; }); \ud83d\udccb Copy We can use the onUpdate() function, which takes a function, and runs it every frame. In this case we're going to increment the score, and update the score label's text every frame. (todo) Full game code here: const FLOOR_HEIGHT = 48; const JUMP_FORCE = 800; const SPEED = 480; // initialize context kaboom(); // load assets loadSprite(\"bean\", \"sprites/bean.png\"); scene(\"game\", () => { // define gravity setGravity(1600); // add a game object to screen const player = add([ // list of components sprite(\"bean\"), pos(80, 40), area(), body(), ]); // floor add([ rect(width(), FLOOR_HEIGHT), outline(4), pos(0, height()), anchor(\"botleft\"), area(), body({ isStatic: true }), color(127, 200, 255), ]); function jump() { if (player.isGrounded()) { player.jump(JUMP_FORCE); } } // jump when user press space onKeyPress(\"space\", jump); onClick(jump); function spawnTree() { // add tree obj add([ rect(48, rand(32, 96)), area(), outline(4), pos(width(), height() - FLOOR_HEIGHT), anchor(\"botleft\"), color(255, 180, 255), move(LEFT, SPEED), \"tree\", ]); // wait a random amount of time to spawn next tree wait(rand(0.5, 1.5), spawnTree); } // start spawning trees spawnTree(); // lose if player collides with any game obj with tag \"tree\" player.onCollide(\"tree\", () => { // go to \"lose\" scene and pass the score go(\"lose\", score); burp(); addKaboom(player.pos); }); // keep track of score let score = 0; const scoreLabel = add([ text(score), pos(24, 24), ]); // increment score every frame onUpdate(() => { score++; scoreLabel.text = score; }); }); scene(\"lose\", (score) => { add([ sprite(\"bean\"), pos(width() / 2, height() / 2 - 80), scale(2), anchor(\"center\"), ]); // display score add([ text(score), pos(width() / 2, height() / 2 + 80), scale(2), anchor(\"center\"), ]); // go back to game with space is pressed onKeyPress(\"space\", () => go(\"game\")); onClick(() => go(\"game\")); }); go(\"game\"); \ud83d\udccb Copy function copyCode() { const codeBox = document.getElementById('codeBox'); const code = codeBox.querySelector('code').innerText; navigator.clipboard.writeText(code) .then(() => alert('Code copied to clipboard!')) .catch(err => console.error('Unable to copy code', err)); }","title":"Javascript Game with kaboom."},{"location":"#javascript-game-with-kaboom","text":"/* Add some basic styling for the code box */ pre { background-color: #f4f4f4; padding: 10px; border-radius: 5px; } /* Optional: Style the code for better readability */ code { color: #333; font-family: 'Courier New', monospace; font-size: 15px; } .copy-button { position: absolute; top: 5px; right: 5px; cursor: pointer; } Today we will be learning how to make a dino-ish game in javascript lets start 1. Make a index.html file. the index.html file needs 2 elements called a head and a body 2. Make a new kaboom.js game by running npm i kaboom in your project this will make a easy way for you to use servers why? kaboom.js adds the npm run dev function 3. paste this in your html file // import kaboom lib import kaboom from \"https://unpkg.com/kaboom@3000.0.1/dist/kaboom.mjs\"; // initialize kaboom context kaboom(); // add a piece of text at position (120, 80) add([ text(\"hello\"), pos(120, 80), ]); This will make a piece of text on the screen. This is like legos kinda Okay lets start replace the code with /// start the game kaboom() // define gravity setGravity(2400) // load a default sprite loadBean() // add character to screen, from a list of components const player = add([ sprite(\"bean\"), // renders as a sprite pos(120, 80), // position in world area(), // has a collider body(), // responds to physics and gravity ]) \ud83d\udccb Copy and start. After that lets make it jump add this code to your script < onKeyPress(\"space\", () => { // .jump() is provided by the body() component player.jump() }) \ud83d\udccb Copy now before we run lets add a platorm for the player to stand on add this code add([ rect(width(), 48), pos(0, height() - 48), outline(4), area(), body({ isStatic: true }), color(127, 200, 255), ]) \ud83d\udccb Copy Woah! That looks like a lot, but it's actually really simple, let's look at each component rect() renders a rectangle. It accepts 2 arguments, the width and height, which we give it the game width (returned by width()) and height of 48 pixels pos() position. We give it a x: 0 and y: height() - 48 so it sits right on the bottom of the screen outline() renders an outline of 4 pixels area() adds a collider to it body({ isStatic: true }) the object won't move, and all non static objects won't move past it color() makes it render with an RGB color, we give it a R: 127 G: 200 B: 255 which is a blue-ish color Pretty straightforward! Refresh the game and you should see our Bean is now safely landed on a static blue platform. Let's also make sure our Bean can only jump when isGrounded. onKeyPress(\"space\", () => { if (bean.isGrounded()) { bean.jump(); } }); \ud83d\udccb Copy isGrounded() is another function provided by body() component which checks if currently landed on a platform. Now our game is slightly more physically correct. Bean loves challanges. Let's start adding in obstacles to jump over! Time to build a game object from components again. // add tree add([ rect(48, 64), area(), outline(4), pos(width(), height() - 48), anchor(\"botleft\"), color(255, 180, 255), move(LEFT, 240), ]); \ud83d\udccb Copy Challenger appears! Try jumping over it. Oh but it's.. not really fun! Or rather, there's no feedback to whether we managed to jump over the ramp. Let's add some feedback. To do this we'll need to check for collision between the two. First we'll need to give the tree a tag. Any game object can have any number of tags, they're kinda like components but much more light weight. We often use tags to quickly describe behaviors for a group of objects. // add tree add([ rect(48, 64), area(), outline(4), pos(width(), height() - 48), anchor(\"botleft\"), color(255, 180, 255), move(LEFT, 240), \"tree\", // add a tag here ]); \ud83d\udccb Copy To add a tag we simply put a string in the component array. Then we can check for collision between Bean and any object with tag \"tree\". bean.onCollide(\"tree\", () => { addKaboom(bean.pos); shake(); }); \ud83d\udccb Copy .onCollide() is a function provided by the area() component. It registers an event that runs every time the object collides with another object with a certain tag, passed by the first argument. In this case, it means every time Bean collides with another game obj with tag \"tree\", run the callback. Inside the callback we're doing 2 things. addKaboom() spawns an explosion animation which is basically kaboom's logo, it accepts 1 argument the position to spawn, which we pass in the player's current position with .pos (which is provided by the pos() component). The second thing is shake(), which just shakes the screen, Here's a trick. Try pressing F1 in the game. See all the blue outlines? This is inspect mode and it'll show all the bounding boxes of every game obj with area() component. Also try hovering over each game object to inspect its states like position and tags. Now it's time to add more trees. How can we keep them spawning constantly? Let's try the loop() function, which performs an action every x seconds. loop(1, () => { // add tree add([ rect(48, 64), area(), outline(4), pos(width(), height() - 48), anchor(\"botleft\"), color(255, 180, 255), move(LEFT, 240), \"tree\", // add a tag here ]); }); \ud83d\udccb Copy Let's just put the tree adding code inside a loop(). The first argument is the time in seconds here, so it'll spawn a tree every 1 seconds. Sick! Lots of trees coming to you now. Now we already have most of the game mechanics done. Some improvements we can make: It might be better if trees all have different random heights. We can use rand() to assign different value to the tree's rect height: function spawnTree() { add([ // the tree components ]); wait(rand(0.5, 1.5), () => { spawnTree(); }); } spawnTree(); \ud83d\udccb Copy See? We're calling spawnTree() recursively / endlessly, with a random interval between 0.5 - 1.5 seconds each time. Before adding a score counter, let's actually complete the game loop first, by sending player to a gameover scene when they hit a tree. We can achieve this with kaboom's scene() system scene(\"game\", () => { add([ sprite(\"bean\"), ]) }) scene(\"lose\", () => { add([ text(\"Game Over\"), ]) }) go(\"game\") \ud83d\udccb Copy Consider this example above, we're declaring 2 scenes here, \"game\" and \"lose\". The function we pass to scene() is the function to run when this scene is activated (by go()). In this case, we want to add a \"bean\" sprite on \"game\" scene, and want to add a \"Game Over\" text on the \"lose\" scene. Let's first move everything game code we have into a scene. // don't move these init / loader functions kaboom() loadSprite(\"bean\", \"sprites/bean.png\"); scene(\"game\", () => { // add bean // add platform // spawn trees }); go(\"game\") \ud83d\udccb Copy Try this, this shouldn't change any of your game's content. Then we can add a \"lose\" scene independent to your core game content here scene(\"lose\", () => { add([ text(\"Game Over\"), pos(center()), anchor(\"center\"), ]) }) \ud83d\udccb Copy So in the \"lose\" scene, we'll add a piece of text in the center says \"Game Over\" (text() is a component that renders text). Go ahead and go to this scene when player collides with a tree: player.onCollide(\"tree\", () => { addKaboom(bean.pos); shake(); go(\"lose\"); // go to \"lose\" scene here }); \ud83d\udccb Copy Ok! Now we've arrived at the final part of our game: score counter. let score = 0; const scoreLabel = add([ text(score), pos(24, 24) ]) \ud83d\udccb Copy Here we've declared a number variable to store the score, and added a game obj with text() component to display the text. Let's keep it simple and just use time as score. // increment score every frame onUpdate(() => { score++; scoreLabel.text = score; }); \ud83d\udccb Copy We can use the onUpdate() function, which takes a function, and runs it every frame. In this case we're going to increment the score, and update the score label's text every frame. (todo) Full game code here: const FLOOR_HEIGHT = 48; const JUMP_FORCE = 800; const SPEED = 480; // initialize context kaboom(); // load assets loadSprite(\"bean\", \"sprites/bean.png\"); scene(\"game\", () => { // define gravity setGravity(1600); // add a game object to screen const player = add([ // list of components sprite(\"bean\"), pos(80, 40), area(), body(), ]); // floor add([ rect(width(), FLOOR_HEIGHT), outline(4), pos(0, height()), anchor(\"botleft\"), area(), body({ isStatic: true }), color(127, 200, 255), ]); function jump() { if (player.isGrounded()) { player.jump(JUMP_FORCE); } } // jump when user press space onKeyPress(\"space\", jump); onClick(jump); function spawnTree() { // add tree obj add([ rect(48, rand(32, 96)), area(), outline(4), pos(width(), height() - FLOOR_HEIGHT), anchor(\"botleft\"), color(255, 180, 255), move(LEFT, SPEED), \"tree\", ]); // wait a random amount of time to spawn next tree wait(rand(0.5, 1.5), spawnTree); } // start spawning trees spawnTree(); // lose if player collides with any game obj with tag \"tree\" player.onCollide(\"tree\", () => { // go to \"lose\" scene and pass the score go(\"lose\", score); burp(); addKaboom(player.pos); }); // keep track of score let score = 0; const scoreLabel = add([ text(score), pos(24, 24), ]); // increment score every frame onUpdate(() => { score++; scoreLabel.text = score; }); }); scene(\"lose\", (score) => { add([ sprite(\"bean\"), pos(width() / 2, height() / 2 - 80), scale(2), anchor(\"center\"), ]); // display score add([ text(score), pos(width() / 2, height() / 2 + 80), scale(2), anchor(\"center\"), ]); // go back to game with space is pressed onKeyPress(\"space\", () => go(\"game\")); onClick(() => go(\"game\")); }); go(\"game\"); \ud83d\udccb Copy function copyCode() { const codeBox = document.getElementById('codeBox'); const code = codeBox.querySelector('code').innerText; navigator.clipboard.writeText(code) .then(() => alert('Code copied to clipboard!')) .catch(err => console.error('Unable to copy code', err)); }","title":"Javascript Game with kaboom."}]}